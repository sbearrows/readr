---
title: "Introduction to readr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to readr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

Importing and exporting data to and from R is an important operation to master.
Here, we will review how to use readr's suite of functions to do just that.

First, let's load the readr package.

```{r}
library(readr)
```

## Data importing

To import data into Rstudio, there are a number of different readr functions to import different types of data files found in the wild:

* `read_csv()`: comma separated values (CSV) files
* `read_tsv()`: tab separated values (TSV) files
* `read_delim()`: general delimited files (including CSV and TSV)
* `read_fwf()`: fixed width files
* `read_table()`: tabular files where columns are separated by white-space.
* `read_log()`: web log files

For delimited files, `read_delim()` will work for both csv and tsv files. There are certain arguments in `read_delim()` that are so commonly used together, they are offered as defaults. These include `read_csv()` and `read_tsv()`.

For R users who need `read_csv()` to use ',' as the decimal point and ';' as a field separator, `read_csv2()` offers these as default arguments. 

## Optional Arguments

It's often the case that our data needs some help to importing into R.
The readr functions come with several optional arguments to make data importing easier.
Because these arguments are conserved across functions, we can demonstrate them using `read_csv()`.

### skip

```{r}
filepath <- readr_example("skip-lines.csv")
writeLines(read_lines(filepath))
read_csv(filepath, skip = 5)
```

### na

```{r}
filepath <- readr_example("interpret-nas.csv")
writeLines(read_lines(filepath))
read_csv(filepath, na = "-")
```

### reading in multiple files

```{r}
```

### id

```{r}
```

### trim white space

```{r}
trim <- tibble::tibble(x = c("high ", " medium", "low", "medium low"), y = c(10, 10, 10, 15))
tfile <- tempfile("trim-whitespace_example-", fileext = ".csv")
write_csv(trim, tfile)
writeLines(read_lines(tfile))
```

```{r}
read_csv(tfile, trim_ws = TRUE)
```

### lazy

```{r}
chicken_data <- read_csv(readr_example("chickens.csv"))
chicken_data <- chicken_data %>% dplyr::filter(sex == "hen")
chicken_data
```

### n_max

```{r}
read_csv(readr_example("mtcars.csv"), n_max = 5)
read_csv(readr_example("mtcars.csv"))
```

### quote

```{r}
filepath <- readr_example("chickens.csv")
writeLines(read_lines(filepath))
read_csv(filepath, quote = "\"")
```

### col_types

In general, it's good practice to supply an explicit column specification.
Sometimes, you don't know what column specification to use, which is why readr packages will guess it for you, if not specified.
But as your analysis matures, providing readr with column specification will ensures that you get warnings if the data changes in unexpected ways.

The available specifications are: (with string abbreviations in brackets)

* `col_logical()` [l], containing only `T`, `F`, `TRUE` or `FALSE`.
* `col_integer()` [i], integers.
* `col_double()` [d], doubles.
* `col_character()` [c], everything else.
* `col_factor(levels, ordered)` [f], a fixed set of values.
* `col_date(format = "")` [D]: with the locale's `date_format`.
* `col_time(format = "")` [t]: with the locale's `time_format`.
* `col_datetime(format = "")` [T]: ISO8601 date times
* `col_number()` [n], numbers containing the `grouping_mark`
* `col_skip()` [_, -], don't import this column.
* `col_guess()` [?], parse using the "best" type based on the input.

To provide readr functions with column specification, use the `col_types` argument.


```{r}
read_csv(readr_example("chickens.csv"),
         col_types = cols(
           chicken = col_character(),
           sex = col_character(),
           eggs_laid = col_integer(),
           motto = col_character()))
```
    
## Troubleshooting

```{r}
df1 <- read_csv(readr_example("problems.csv"))
```

If the column type guessing fails, readr will generate a data frame of problems.
The first few will be printed out, and you can access them all with `problems()`:

```{r}
problems(df1)
```



```{r}
read_lines(readr_example("problems.csv"), skip = 300, n_max = 1)
```

---
title: "Introduction to readr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to readr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

```{r}
library(readr)
```


```{r}
df1 <- read_csv(readr_example("challenge.csv"))
```

The rectangular parsing functions almost always succeed; they'll only fail if the format is severely messed up.
Instead, readr will generate a data frame of problems.
The first few will be printed out, and you can access them all with `problems()`:

```{r}
problems(df1)
```

You've already seen one way of handling bad guesses: increasing the number of rows used to guess the type of each column. 

```{r}
df2 <- read_csv(readr_example("challenge.csv"), guess_max = 1001)
```

Another approach is to manually supply the column specification.

### Overriding the defaults

You can also access it after the fact using `spec()`:

```{r}
spec(df1)
spec(df2)
```

This also allows you to access the full column specification.

If you want to manually specify the column types, you can start by copying and pasting this code, and then tweaking it fix the parsing problems.

```{r}
df3 <- read_csv(
  readr_example("challenge.csv"), 
  col_types = list(
    x = col_double(),
    y = col_date(format = "")
  )
)
```

In general, it's good practice to supply an explicit column specification.
It is more work, but it ensures that you get warnings if the data changes in unexpected ways.
To be really strict, you can use `stop_for_problems(df3)`.
This will throw an error if there are any parsing problems, forcing you to fix those problems before proceeding with the analysis.

### Available column specifications

The available specifications are: (with string abbreviations in brackets)

* `col_logical()` [l], containing only `T`, `F`, `TRUE` or `FALSE`.
* `col_integer()` [i], integers.
* `col_double()` [d], doubles.
* `col_character()` [c], everything else.
* `col_factor(levels, ordered)` [f], a fixed set of values.
* `col_date(format = "")` [D]: with the locale's `date_format`.
* `col_time(format = "")` [t]: with the locale's `time_format`.
* `col_datetime(format = "")` [T]: ISO8601 date times
* `col_number()` [n], numbers containing the `grouping_mark`
* `col_skip()` [_, -], don't import this column.
* `col_guess()` [?], parse using the "best" type based on the input.

Use the `col_types` argument to override the default choices.
There are two ways to use it:

* With a string: `"dc__d"`: read first column as double, second as character,
  skip the next two and read the last column as a double. (There's no way to
  use this form with types that take additional parameters.)
  
* With a (named) list of col objects:

    ```{r}
    read_csv("iris.csv", col_types = list(
      Sepal.Length = col_double(),
      Sepal.Width = col_double(),
      Petal.Length = col_double(),
      Petal.Width = col_double(),
      Species = col_factor(c("setosa", "versicolor", "virginica"))
    ))
    ```
    
  Or, with their abbreviations:
    
    ```{r}
      read_csv("iris.csv", col_types = list(
      Sepal.Length = "d",
      Sepal.Width = "d",
      Petal.Length = "d",
      Petal.Width = "d",
      Species = col_factor(c("setosa", "versicolor", "virginica"))
    ))
    ```
    
Any omitted columns will be parsed automatically, so the previous call
will lead to the same result as:

```{r}
read_csv("iris.csv", col_types = list(
  Species = col_factor(c("setosa", "versicolor", "virginica")))
)
```

You can also set a default type that will be used instead of
relying on the automatic detection for columns you don't specify:

```{r}
read_csv("iris.csv", col_types = list(
  Species = col_factor(c("setosa", "versicolor", "virginica")),
  .default = col_double())
)
```

If you only want to read specified columns, use `cols_only()`:

```{r}
read_csv("iris.csv", col_types = cols_only(
  Species = col_factor(c("setosa", "versicolor", "virginica")))
)
```

### Output

The output of all these functions is a tibble.
Note that characters are never automatically converted to factors (i.e. no more `stringsAsFactors = FALSE`) and column names are left as is, not munged into valid R identifiers (i.e. there is no `check.names = TRUE`).
Row names are never set.

Attributes store the column specification (`spec()`) and any parsing problems (`problems()`).
